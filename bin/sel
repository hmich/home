#!/usr/bin/env python

# Copyright (c) 2008 Igor Akhmetov
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

from __future__ import with_statement

import os
import os.path
import sys
import re
import string
import optparse

import curses
import curses.ascii
import curses.textpad
import curses.wrapper

VERSION=0.1
PATTERN_TIMEOUT = 2000
NOTHING_SELECTED_EXIT_STATUS = 1

def cyclic_xrange(start, cnt):
    for idx in xrange(start, cnt):
        yield idx
    for idx in xrange(start):
        yield idx

def listdir_sorted(dir):
    entries = sorted((f for f in os.listdir(dir)), key=string.lower)
    dirs = [f for f in entries if os.path.isdir(os.path.join(dir, f))]
    files = [f for f in entries if os.path.isfile(os.path.join(dir, f))]
    return dirs + files

class Item(object):
    def __init__(self, str, idx, callback):
        self._str = str
        self._marked = False
        self._callback = callback
        self._idx = idx

    def _getmarked(self):
        return self._marked

    def _setmarked(self, val):
        if self._marked != val:
            self._marked = val
            self._callback(self._idx, val)

    marked = property(_getmarked, _setmarked)

    def __str__(self):
        return self._str

class Items:
    def __init__(self, matches, item_changed_callback, has_marked_callback):
        self._items = [Item(match, idx, self._item_state_changed)
                       for (idx, match) in enumerate(matches)]
        self._nmarked = 0
        self._item_changed_callback = item_changed_callback
        self._has_marked_callback = has_marked_callback

    def has_marked(self):
        return self._nmarked > 0

    def remove(self, items):
        for idx in reversed(list(items)):
            del self._items[idx]
        for (idx, item) in enumerate(self._items):
            item._idx = idx
        self._nmarked = sum(int(item.marked) for item in self._items)

    def _item_state_changed(self, idx, val):
        nmarked = self._nmarked
        self._nmarked += 1 if val else -1

        self._item_changed_callback(idx)
        if not nmarked or not self._nmarked:
            self._has_marked_callback()

    def __len__(self):
        return len(self._items)

    def __getitem__(self, idx):
        return self._items[idx]

class Status:
    def __init__(self):
        self.win = curses.newwin(1, curses.COLS, curses.LINES - 1, 0)
        self.win.attrset(curses.color_pair(0))

    def clear(self):
        self.win.move(0, 0)
        self.win.clrtoeol()

    def put(self, str):
        self.clear()
        self.win.addstr(str)
        self.win.refresh()

    def query(self, str):
        str += ' '
        self.put(str)
        win = curses.newwin(1, curses.COLS - len(str), curses.LINES - 1, len(str))
        return curses.textpad.Textbox(win).edit()

class Screen:
    def __init__(self, matches):
        self.offset = 0
        self.idx = 0
        self.dir = os.getcwd()
        self.items = Items(matches, self.draw_item, self.redraw)

    def getch(self):
        self.scr.timeout(PATTERN_TIMEOUT)
        return self.scr.getch()

    def bound_idx(self, idx):
        return max(0, min(idx, len(self.items) - 1))

    def bound_offset(self, offset):
        return max(0, min(offset, len(self.items) - self.lines))

    def contains_line(self, line):
        return self.offset <= line < self.offset + self.lines

    def item_line(self, idx):
        item = self.items[idx]
        has_marked = self.items.has_marked()
        fmt = (('[%(marked)s] ' if has_marked else '') +
               ('[%(text)s]' if self.is_dir(idx) else '%(text)s'))

        return fmt % {'marked': 'x' if item.marked else ' ', 'text': str(item)}

    def draw_item(self, idx):
        if idx >= len(self.items) or not self.contains_line(idx):
            return

        y = idx - self.offset
        line_num = str(idx + 1).rjust(len(str(len(self.items))) + 1) + ' '
        item = self.items[idx]
        s = self.item_line(idx)

        self.clear_line(y)
        self.scr.attrset(curses.color_pair(0))
        self.scr.addstr(y, 0, line_num)

        attr = curses.color_pair(0)
        if item.marked:
            attr |= curses.A_BOLD
        if self.idx == idx:
            attr |= curses.color_pair(1)
        elif self.is_dir(idx):
            attr |= curses.color_pair(2) | curses.A_BOLD

        self.scr.attrset(attr)
        self.scr.addstr(y, len(line_num), s + ' ' * (curses.COLS - len(s) - len(line_num)))
        self.scr.refresh()

    def clear_line(self, line):
        self.scr.move(line, 0)
        self.scr.clrtoeol()

    def redraw(self):
        for curidx in xrange(self.offset, self.offset + self.lines):
            if curidx < len(self.items):
                self.draw_item(curidx)
            else:
                self.clear_line(curidx - self.offset)

    def _change_item(self, arg):
        previdx, prevoffset = self.idx, self.offset

        self.idx = self.bound_idx(arg)
        if not self.contains_line(self.idx):
            if self.idx < self.offset:
                self.offset = self.idx
            else:
                self.offset = self.idx - self.lines + 1

        self.offset = self.bound_offset(self.offset)

        if self.offset == prevoffset:
            self.draw_item(previdx)
            self.draw_item(self.idx)
        else:
            self.redraw()

    next_item  = lambda self: self._change_item(self.idx + 1)
    prev_item  = lambda self: self._change_item(self.idx - 1)
    first_item = lambda self: self._change_item(0)
    last_item  = lambda self: self._change_item(len(self.items) - 1)

    def next_page(self):
        if self.idx - self.offset == self.lines - 1:
            self._change_item(self.idx + self.lines)
        else:
            self._change_item(self.offset + self.lines - 1)

    def prev_page(self):
        if self.idx == self.offset:
            self._change_item(self.idx - self.lines)
        else:
            self._change_item(self.offset)

    def current_item(self):
        return self.items[self.idx]

    def toggle_item(self):
        item = self.current_item()
        item.marked = not item.marked

    def invert_selection(self):
        for item in self.items:
            item.marked = not item.marked

    def select_all(self):
        for item in self.items:
            item.marked = True

    def update_status(self):
        nitems = len(self.items)
        nvisible_items = min(nitems - self.offset + 1, self.lines)
        msg = "%d-%d of %d" % (self.offset + 1, self.offset + nvisible_items, nitems)
        self.status.put(self.dir + msg.rjust(curses.COLS - len(self.dir) - 1))

    def goto_line(self):
        linestr = self.status.query("Goto line:")
        try:
            line = int(linestr)
        except ValueError:
            return
        self._change_item(line - 1)

    def mark_by_regex(self):
        s = self.status.query("Mark by regex:")
        try:
            regex = re.compile(s.strip(), re.IGNORECASE)
        except:
            return

        for item in self.items:
            if regex.search(str(item)):
                item.marked = True

    def _focus_pattern(self, startidx):
        for idx in cyclic_xrange(startidx, len(self.items)):
            if self.pattern in str(self.items[idx]).lower():
                self._change_item(idx)
                break

    def _focus_regex(self, startidx):
        for idx in cyclic_xrange(startidx, len(self.items)):
            if self.regex.search(str(self.items[idx])):
                self._change_item(idx)
                break

    def focus_pattern(self, pat):
        self.regex = None
        self.pattern = pat
        self._focus_pattern(self.idx)

    def search_by_regex(self):
        s = self.status.query("Search by regex:")
        try:
            self.regex = re.compile(s.strip(), re.IGNORECASE)
        except:
            return

        self.pattern = None
        self._focus_regex(self.idx)

    def next_match(self):
        if self.pattern:
            self._focus_pattern(self.idx + 1)
        elif self.regex:
            self._focus_regex(self.idx + 1)

    def enumerate_selected(self):
        if self.items.has_marked():
            for (idx, item) in enumerate(self.items):
                if item.marked:
                    yield (idx, item)
        else:
            yield (self.idx, self.current_item())

    def remove_marked(self):
        self.items.remove(idx for (idx, _) in self.enumerate_selected())
        if not self.items:
            return

        self._change_item(self.idx)
        self.redraw()

    def init_curses(self):
        curses.use_default_colors()
        curses.init_pair(0, curses.COLOR_WHITE, -1)
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.init_pair(2, curses.COLOR_BLUE, -1)

        # sometimes raises an exception in cygwin
        try:
            curses.curs_set(0)
        except:
            pass

    def is_dir(self, idx = None):
        idx = idx or self.idx
        return os.path.isdir(os.path.join(self.dir, str(self.items[idx])))

    def read_dir(self, dir):
        if not os.path.isabs(dir):
            dir = os.path.join(self.dir, dir)

        entries = listdir_sorted(dir)

        self.dir = os.path.abspath(dir)
        self.offset = 0
        self.idx = 0
        self.items = Items(entries, self.draw_item, self.redraw)

        self.redraw()

    def up_dir(self):
        self.read_dir(os.path.split(self.dir)[0])

    def mainloop(self, stdscr):
        self.init_curses()
        self.status = Status()
        self.scr = stdscr
        self.lines = curses.LINES - 1
        self.redraw()

        bindings = {
            curses.KEY_DOWN:      self.next_item,
            ord('J'):             self.next_item,
            14:                   self.next_item, # Ctrl-N
            curses.KEY_UP:        self.prev_item,
            ord('K'):             self.prev_item,
            16:                   self.prev_item, # Ctrl-P
            curses.KEY_NPAGE:     self.next_page,
            ord('H'):             self.next_page,
            6:                    self.next_page, # Ctrl-F
            curses.KEY_PPAGE:     self.prev_page,
            ord('L'):             self.prev_page,
            2:                    self.prev_page, # Ctrl-B
            curses.KEY_HOME:      self.first_item,
            ord('<'):             self.first_item,
            curses.KEY_END:       self.last_item,
            ord('>'):             self.last_item,
            curses.KEY_DC:        self.remove_marked,
            ord('D'):             self.remove_marked,
            curses.KEY_IC:        self.toggle_item,
            ord(' '):             self.toggle_item,
            ord('!'):             self.invert_selection,
            ord('*'):             self.select_all,
            ord('G'):             self.goto_line,
            ord('%'):             self.mark_by_regex,
            ord('/'):             self.search_by_regex,
            ord('N'):             self.next_match,
            curses.KEY_BACKSPACE: self.up_dir,
            ord('^'):             self.up_dir,
        }

        res = []
        pattern = ''
        while 1:
            self.update_status()

            try:
                c = self.getch()
            except KeyboardInterrupt:
                break

            # log = open('log', 'a')
            # log.write(str(c) + '\n')

            if c == 4: # Ctrl-D
                res = [self.dir]
                break
            elif c == ord('\n'):
                if self.is_dir() and not self.items.has_marked():
                    self.read_dir(str(self.current_item()))
                    pattern = ''
                else:
                    res = [item for (_, item) in self.enumerate_selected()]
                    break
            elif bindings.get(c):
                bindings[c]()
                pattern = ''
                if not self.items:
                    break
            elif curses.ascii.isprint(c):
                pattern += chr(c)
                self.regex = None
                self.focus_pattern(pattern)
            else:
                pattern = ''

        self.scr.clear()
        self.scr.refresh()

        return map(lambda x: os.path.join(self.dir, str(x)), res)

class TTYLocker:
    def __enter__(self):
        self._saved_stdin = os.dup(0)
        self._saved_stdout = os.dup(1)

        os.close(0)
        os.close(1)

        os.open('/dev/tty', os.O_RDONLY)
        os.open('/dev/tty', os.O_RDWR)

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.close(0)
        os.close(1)

        os.dup(self._saved_stdin)
        os.dup(self._saved_stdout)

def process_args():
    parser = optparse.OptionParser(usage='usage: %prog [options] [regexp]...', version='%prog ' + str(VERSION), description=
'''Allows you to quickly select from a number of options,
including filenames and strings parsed from the standard input using regexps.''')

    parser.add_option('-0', '--null', action='store_true', dest='null_terminated', default=False, help='separate output items with null character')
    parser.add_option('-o', '--ofs', action='store', type='string', dest='ofs', default=' ', help='output fields separator, space by default')

    (options, args) = parser.parse_args()
    args = args or ['^.*$']

    return options, [re.compile(s, re.IGNORECASE) for s in args]

def itermatches(regexps):
    for line in sys.stdin.xreadlines():
        for re in regexps:
            for match in re.findall(line):
                yield match

def separator(options):
    return '\x00' if options.null_terminated else options.ofs

def main():
    options, regexps = process_args()
    if os.isatty(0):
        matches = listdir_sorted(os.getcwd())
    else:
        matches = list(itermatches(regexps))
    if not matches:
        sys.exit(NOTHING_SELECTED_EXIT_STATUS)

    with TTYLocker():
        res = curses.wrapper(Screen(matches).mainloop)

    if not res:
        sys.exit(NOTHING_SELECTED_EXIT_STATUS)

    sys.stdout.write(separator(options).join(res))

if __name__ == '__main__':
    main()
