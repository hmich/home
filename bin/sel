#!/usr/bin/env python

from __future__ import with_statement

import os
import sys
import re
import string
import optparse
import curses
from curses.wrapper import wrapper

ESCAPE = 27
PATTERN_TIMEOUT = 2000

def cyclic_xrange(start, cnt):
    for idx in xrange(start, cnt):
        yield idx
    for idx in xrange(start):
        yield idx

class Item(object):
    def __init__(self, str):
        self._str = str
        self._checked = False

    def _getchecked(self):
        return self._checked

    def _setchecked(self, val):
        if not options.select_one:
            self._checked = val

    checked = property(_getchecked, _setchecked)

    def __str__(self):
        return self._str

    def toggle(self):
        self.checked = not self.checked

    def render(self, scr, y):
        scr.move(y, 0)
        scr.clrtoeol()

        s = ''
        if not options.select_one:
            s += '[' + ('x' if self.checked else ' ') + '] '
        s = s + self.__str__()
        scr.addstr(y, 0, s + ' ' * (curses.COLS - len(s) - 1))

class Screen:
    def __init__(self, items, scr):
        #scr.scrollok(1)

        self.scr = scr
        self.idx = 0
        self.offset = 0
        self.items = items
        self.lines = curses.LINES - 1

    def getch(self):
        self.scr.timeout(PATTERN_TIMEOUT)
        return self.scr.getch()

    def refresh(self):
        self.scr.refresh()

    def items_num(self):
        return len(self.items)

    def bound_idx(self, idx):
        return max(0, min(idx, self.items_num() - 1))

    def bound_offset(self, offset):
        return max(0, min(offset, self.items_num() - self.lines))

    def contains_line(self, line):
        return self.offset <= line < self.offset + self.lines

    def draw_item(self, idx):
        if not self.contains_line(idx):
            return

        item = items[idx]

        attr = curses.color_pair(0)
        if item.checked:
            attr |= curses.A_BOLD
        if self.idx == idx:
            attr |= curses.color_pair(1)
        self.scr.attrset(attr)

        item.render(self.scr, idx - self.offset)
        self.refresh()

    def redraw(self):
        for curidx in xrange(self.items_num()):
            self.draw_item(curidx)

    def _change_item(self, arg):
        previdx = self.idx

        self.idx = self.bound_idx(arg)
        if not self.contains_line(self.idx):
            if self.idx < self.offset:
                self.offset = self.idx
            else:
                self.offset = self.idx - self.lines + 1

        self.redraw()

    next_item  = lambda self: self._change_item(self.idx + 1)
    prev_item  = lambda self: self._change_item(self.idx - 1)
    first_item = lambda self: self._change_item(0)
    last_item  = lambda self: self._change_item(self.items_num() - 1)

    def next_page(self):
        if self.idx - self.offset == self.lines - 1:
            self._change_item(self.idx + self.lines)
        else:
            self._change_item(self.offset + self.lines - 1)

    def prev_page(self):
        if self.idx == self.offset:
            self._change_item(self.idx - self.lines)
        else:
            self._change_item(self.offset)

    def current_item(self):
        return self.items[self.idx]

    def toggle_item(self):
        item = self.current_item()
        item.toggle()
        self.draw_item(self.idx)

    def deselect_all(self):
        for item in self.items:
            item.checked = False

    def invert_selection(self):
        for item in self.items:
            item.toggle()
        self.redraw()

    def focus_pattern(self, pat):
        for idx in cyclic_xrange(self.idx, self.items_num()):
            if pat in str(self.items[idx]).lower():
                self._change_item(idx)
                break

class TTYLocker:
    def __enter__(self):
        self._saved_stdin = os.dup(0)
        self._saved_stdout = os.dup(1)

        os.close(0)
        os.close(1)

        os.open('/dev/tty', os.O_RDONLY)
        os.open('/dev/tty', os.O_RDWR)

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.close(0)
        os.close(1)

        os.dup(self._saved_stdin)
        os.dup(self._saved_stdout)

def process_args():
    parser = optparse.OptionParser()
    parser.add_option('-a', '--all', action='store_true', dest='select_all', default=False)
    parser.add_option('-1', '', action='store_true', dest='select_one', default=False)
    parser.add_option('-l', '--lines', action='store_true', dest='lines_regex', default=False)

    global options
    (options, args) = parser.parse_args()

    if options.lines_regex:
        args.append('^.*$')
    args = args or ['[\S]+']
    return [re.compile(str) for str in args]

def find_matches(regexps):
    res = []
    for line in sys.stdin.xreadlines():
        for re in regexps:
            res.extend(re.findall(line))
    return res

def mainloop(stdscr):
    curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

    scr = Screen(items, stdscr)
    scr.redraw()

    pattern = ''

    while 1:
        c = scr.getch()

        bindings = {
            curses.KEY_DOWN:  Screen.next_item,
            curses.KEY_UP:    Screen.prev_item,
            curses.KEY_NPAGE: Screen.next_page,
            curses.KEY_PPAGE: Screen.prev_page,
            curses.KEY_HOME:  Screen.first_item,
            curses.KEY_END:   Screen.last_item,
            ord('!'):         Screen.invert_selection,
            ord(' '):         Screen.toggle_item }

        if c == ord('\n'):
            if options.select_one:
                return [scr.current_item()]
            else:
                return [item for item in scr.items if item.checked]
        #elif c == ESCAPE:
        #     break
        elif bindings.get(c):
            bindings[c](scr)
            pattern = ''
        elif 0 <= c < 256 and (chr(c) in string.printable):
            pattern += chr(c)
            scr.focus_pattern(pattern)
        else:
            pattern = ''

    return []

def main():
    regexps = process_args()

    global items
    items = [Item(str) for str in find_matches(regexps)]

    if not items:
        return

    if len(items) == 1 and options.select_one:
        print items[0]
        return

    if options.select_all:
        for item in items:
            item.toggle()

    os.putenv('ESCDELAY', '0')
    with TTYLocker():
        items = wrapper(mainloop)

    for item in items:
        print '"' + item.__str__() + '"',

if __name__ == '__main__':
    main()
