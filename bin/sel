#!/usr/bin/env python

from __future__ import with_statement

import os
import sys
import re
import string
import optparse

import curses
import curses.textpad
from curses.wrapper import wrapper

ESCAPE = 27
PATTERN_TIMEOUT = 2000

def cyclic_xrange(start, cnt):
    for idx in xrange(start, cnt):
        yield idx
    for idx in xrange(start):
        yield idx

class Item(object):
    def __init__(self, str):
        self._str = str
        self._checked = False

    def _getchecked(self):
        return self._checked

    def _setchecked(self, val):
        if not options.select_one:
            self._checked = val

    checked = property(_getchecked, _setchecked)

    def __str__(self):
        return self._str

    def toggle(self):
        self.checked = not self.checked

    def render(self, scr, y, fmt):
        scr.move(y, 0)
        scr.clrtoeol()

        s = ''
        if not options.select_one:
            s += '[' + ('x' if self.checked else ' ') + '] '
        s = s + self.__str__()
        s = fmt % s
        scr.addstr(y, 0, s + ' ' * (curses.COLS - len(s) - 1))

class Screen:
    def __init__(self, items):
        self.idx = 0
        self.offset = 0
        self.items = items

    def getch(self):
        self.scr.timeout(PATTERN_TIMEOUT)
        return self.scr.getch()

    def refresh(self):
        self.scr.refresh()

    def items_num(self):
        return len(self.items)

    def bound_idx(self, idx):
        return max(0, min(idx, self.items_num() - 1))

    def bound_offset(self, offset):
        return max(0, min(offset, self.items_num() - self.lines))

    def contains_line(self, line):
        return self.offset <= line < self.offset + self.lines

    def draw_item(self, idx):
        if not self.contains_line(idx):
            return

        item = self.items[idx]

        attr = curses.color_pair(0)
        if item.checked:
            attr |= curses.A_BOLD
        if self.idx == idx:
            attr |= curses.color_pair(1)
        self.scr.attrset(attr)

        fmt = str(idx + 1).rjust(len(str(self.items_num())) + 1) + " %s"
        item.render(self.scr, idx - self.offset, fmt)
        self.refresh()

    def redraw(self):
        for curidx in xrange(self.items_num()):
            self.draw_item(curidx)

    def _change_item(self, arg):
        previdx = self.idx

        self.idx = self.bound_idx(arg)
        if not self.contains_line(self.idx):
            if self.idx < self.offset:
                self.offset = self.idx
            else:
                self.offset = self.idx - self.lines + 1

        self.redraw()

    next_item  = lambda self: self._change_item(self.idx + 1)
    prev_item  = lambda self: self._change_item(self.idx - 1)
    first_item = lambda self: self._change_item(0)
    last_item  = lambda self: self._change_item(self.items_num() - 1)

    def next_page(self):
        if self.idx - self.offset == self.lines - 1:
            self._change_item(self.idx + self.lines)
        else:
            self._change_item(self.offset + self.lines - 1)

    def prev_page(self):
        if self.idx == self.offset:
            self._change_item(self.idx - self.lines)
        else:
            self._change_item(self.offset)

    def current_item(self):
        return self.items[self.idx]

    def toggle_item(self):
        item = self.current_item()
        item.toggle()
        self.draw_item(self.idx)

    def deselect_all(self):
        for item in self.items:
            item.checked = False

    def invert_selection(self):
        for item in self.items:
            item.toggle()
        self.redraw()

    def focus_pattern(self, pat):
        for idx in cyclic_xrange(self.idx, self.items_num()):
            if pat in str(self.items[idx]).lower():
                self._change_item(idx)
                break

    def print_status(self, str):
        self.scr.move(curses.LINES - 1, 0)
        self.scr.clrtoeol()
        self.scr.addstr(str)
        self.refresh()

    def query(self, str):
        self.print_status(str)

        win = curses.newwin(1, curses.COLS - len(str), curses.LINES - 1, len(str))
        q = curses.textpad.Textbox(win)
        res = q.edit()

        self.print_status('')

        return res

    def goto_line(self):
        line = self.query("Goto line: ")
        self._change_item(int(line) - 1)

    def mainloop(self, stdscr):
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)

        self.scr = stdscr
        self.lines = curses.LINES - 1
        self.redraw()

        pattern = ''

        while 1:
            c = self.getch()

            bindings = {
                curses.KEY_DOWN:  self.next_item,
                curses.KEY_UP:    self.prev_item,
                curses.KEY_NPAGE: self.next_page,
                curses.KEY_PPAGE: self.prev_page,
                curses.KEY_HOME:  self.first_item,
                curses.KEY_END:   self.last_item,
                ord('G'):         self.goto_line,
                ord('!'):         self.invert_selection,
                ord(' '):         self.toggle_item }

            if c == ord('\n'):
                if options.select_one:
                    return [self.current_item()]
                else:
                    return [item for item in self.items if item.checked]
            elif bindings.get(c):
                bindings[c]()
                pattern = ''
            elif 0 <= c < 256 and (chr(c) in string.printable):
                pattern += chr(c)
                self.focus_pattern(pattern)
            else:
                pattern = ''

        return []

class TTYLocker:
    def __enter__(self):
        self._saved_stdin = os.dup(0)
        self._saved_stdout = os.dup(1)

        os.close(0)
        os.close(1)

        os.open('/dev/tty', os.O_RDONLY)
        os.open('/dev/tty', os.O_RDWR)

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.close(0)
        os.close(1)

        os.dup(self._saved_stdin)
        os.dup(self._saved_stdout)

def process_args():
    parser = optparse.OptionParser()
    parser.add_option('-a', '--all', action='store_true', dest='select_all', default=False)
    parser.add_option('-1', '', action='store_true', dest='select_one', default=False)
    parser.add_option('-l', '--lines', action='store_true', dest='lines_regex', default=False)

    global options
    (options, args) = parser.parse_args()

    if options.lines_regex:
        args.append('^.*$')
    args = args or ['[\S]+']

    return [re.compile(str) for str in args]

def find_matches(regexps):
    res = []
    for line in sys.stdin.xreadlines():
        for re in regexps:
            res.extend(re.findall(line))
    return res

def main():
    regexps = process_args()

    items = [Item(str) for str in find_matches(regexps)]

    if not items:
        return

    if len(items) == 1 and options.select_one:
        print items[0]
        return

    if options.select_all:
        for item in items:
            item.toggle()

    scr = Screen(items)

    os.putenv('ESCDELAY', '0')
    with TTYLocker():
        items = wrapper(scr.mainloop)

    for item in items:
        # print '"' + item.__str__() + '"',
        print item.__str__(),

if __name__ == '__main__':
    main()
