#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright (c) 2008 Igor Akhmetov (Igor.Akhmetov at gmail dot com)
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

from __future__ import with_statement

import os
import os.path
import sys
import subprocess
import signal
import pwd
import cgitb

import itertools
from collections import defaultdict
import types
import operator

import time
import struct
import fcntl
import termios

import re
import string
import locale
import unicodedata
import optparse
import logging
from ConfigParser import RawConfigParser

import curses
import curses.textpad
import curses.wrapper

VERSION = '0.1'            # current program version
PATTERN_TIMEOUT = 2        # time in seconds to wait before resetting the typed pattern
CONFIG_FILE = u'~/.selrc'  # name of the file which stores configuration settings
DEFAULT_EDITOR = u'vim'    # editor to invoke if the EDITOR environment variable is not set
DEFAULT_PAGER = u'less'    # pager to invoke if the PAGER environment variable is not set

class ExitStatuses:
    NOTHING_SELECTED = 1   # nothing has been selected
    EXEC_ERROR = 2         # exec of the supplied program did not succeed
    INVALID_REGEXP = 3     # invalid regexp for parsing input stream has been passed on the command line

class Attrs:
    """Holds all curses attributes, used in the program."""
    @classmethod
    def init(cls):
        """Initializes the attributes. Modify this method if you want to change the appearance."""
        color = lambda fg, bg: curses.color_pair(ColorsManager.color(fg, bg))

        cls.DEFAULT   = color(curses.COLOR_WHITE, -1)
        cls.STATUS    = cls.DEFAULT
        cls.LINENUM   = cls.DEFAULT
        cls.MARKED    = cls.DEFAULT | curses.A_BOLD
        cls.SELECTED  = color(curses.COLOR_WHITE, curses.COLOR_BLUE) | curses.A_BOLD
        cls.HIGHLIGHT = color(curses.COLOR_WHITE, curses.COLOR_RED) | curses.A_BOLD
        cls.MESSAGE   = cls.HIGHLIGHT
        cls.DIR       = color(curses.COLOR_BLUE, -1) | curses.A_BOLD
        cls.EXEC      = color(curses.COLOR_GREEN, -1 ) | curses.A_BOLD
        cls.LINK      = color(curses.COLOR_CYAN, -1 ) | curses.A_BOLD

class ColorsManager(object):
    _colors = []

    @classmethod
    def init(cls):
        """Initializes curses color pairs."""
        for idx, (fg, bg) in enumerate(cls._colors):
            curses.init_pair(idx, fg, bg)

    @classmethod
    def color(cls, fg, bg):
        """Register new color pair with fg and bg as the foreground and background colors."""
        c = (fg, bg)
        if c in cls._colors:
            return cls._colors.index(c)
        else:
            cls._colors.append(c)
            return len(cls._colors) - 1

class Keys:
    @classmethod
    def init(cls):
        key = cls._register_key

        cls.DOWN      = key(u'KEY_DOWN', u'Down')
        cls.UP        = key(u'KEY_UP', u'Up')
        cls.PAGE_DOWN = key(u'KEY_NPAGE', u'Page Down')
        cls.HOME      = key(u'KEY_HOME', u'Home')
        cls.PAGE_UP   = key(u'KEY_PPAGE', u'Page Up')
        cls.END       = key(u'KEY_END', u'End')
        cls.DELETE    = key(u'KEY_DC', u'Delete')
        cls.INSERT    = key(u'KEY_IC', u'Insert')
        cls.CTRL_H    = key(u'KEY_BACKSPACE', u'Ctrl-H')
        cls.BACKSPACE = key(u'\x7f', u'Backspace')
        cls.CTRL_N    = key(u'\x0e', u'Ctrl-N')
        cls.CTRL_P    = key(u'\x10', u'Ctrl-P')
        cls.CTRL_F    = key(u'\x06', u'Ctrl-F')
        cls.CTRL_B    = key(u'\x02', u'Ctrl-B')
        cls.CTRL_R    = key(u'\x12', u'Ctrl-R')
        cls.CTRL_L    = key(u'\x0c', u'Ctrl-L')
        cls.CTRL_X    = key(u'\x18', u'Ctrl-X')
        cls.CTRL_D    = key(u'\x04', u'Ctrl-D')
        cls.ESCAPE    = key(u'\x1b', u'Escape')
        cls.RETURN    = key(u'\n', u'Return')
        cls.TAB       = key(u'\t', u'Tab')
        cls.F1        = key(u'KEY_F(1)', u'F1')
        cls.F2        = key(u'KEY_F(2)', u'F2')
        cls.F3        = key(u'KEY_F(3)', u'F3')
        cls.F4        = key(u'KEY_F(4)', u'F4')
        cls.F5        = key(u'KEY_F(5)', u'F5')
        cls.F6        = key(u'KEY_F(6)', u'F6')
        cls.F7        = key(u'KEY_F(7)', u'F7')
        cls.F8        = key(u'KEY_F(8)', u'F8')
        cls.F9        = key(u'KEY_F(9)', u'F9')
        cls.F10       = key(u'KEY_F(10)', u'F10')
        cls.F11       = key(u'KEY_F(11)', u'F11')
        cls.F12       = key(u'KEY_F(12)', u'F12')

    _keys = {}
    _revkeys = {}

    @classmethod
    def _register_key(cls, code, str):
        cls._keys[code] = str
        cls._revkeys[str] = code
        return code

    @classmethod
    def str(cls, code):
        if code in cls._keys:
            return cls._keys[code]
        else:
            return "'%s'" % code

    @classmethod
    def code(cls, str):
        if str[0] == "'":
            return str[1:-1]
        else:
            return cls._revkeys[str]

# convenience helpers
fst = operator.itemgetter(0)
snd = operator.itemgetter(1)

# os utilities
def touni(str):
    """Converts a string from the local encoding to the unicode representation."""
    if str is None:
        return None
    return unicode(str, locale.getpreferredencoding())

def fromuni(str):
    """Converts a string from the unicode representation to the local encoding."""
    return str.encode(locale.getpreferredencoding())

def getcwd():
    """Unicode name of the current working directory."""
    return touni(os.getcwd())

def listdir_sorted(dir):
    """Lists directory contents sorted in case-insensitive order. Groups directories before files."""
    # conversion from unicode is needed to allow the program run under cygwin
    for _, dirs, files in os.walk(fromuni(dir)):
        return map(touni, sorted(dirs, key=string.lower) + sorted(files, key=string.lower) or [os.pardir])

def is_executable(cmd):
    """Checks if 'cmd' is in the PATH and is executable."""
    for dir in os.getenv('PATH').split(os.pathsep):
        if os.access(os.path.join(dir, cmd), os.X_OK):
            return True
    return False

def shell_path():
    """Path to the user shell executable.

    >>> is_executable(shell_path())
    True
    """
    return os.getenv('SHELL') or pwd.getpwuid(os.geteuid())[6]

def editor_name():
    """Name of the preferred editor.

    >>> is_executable(editor_name())
    True
    """
    return touni(os.getenv('EDITOR')) or DEFAULT_EDITOR

def pager_name():
    """Name of the preferred pager program.

    >>> is_executable(pager_name())
    True
    """
    return touni(os.getenv('PAGER')) or DEFAULT_PAGER

def program_name():
    """Returns program name."""
    return touni(os.path.basename(sys.argv[0]))

# string utilities
def shell_quote(str):
    """Quotes the string so it can be used as an argument to a shell command.

    >>> s = "a'b\\"c"; os.popen("echo " + shell_quote(s)).read().strip() == s
    True
    """
    return "'%s'" % (str.replace("'", "'\"'\"'"))

def is_printable_char(c):
    """Tests if a wide character is printable.

    >>> is_printable_char(unicode('Ð°', 'utf-8'))
    True
    >>> is_printable_char(unicode('\x09'))
    False
    """
    try:
        return unicodedata.category(c)[0] in 'LNPS'
    except:
        return False

class Item(object):
    def __init__(self, str, action, attr = None):
        self._str = str
        self._marked = False
        self._action = action
        self.attr = attr or Attrs.DEFAULT

    def __eq__(self, other):
        return self._str == other._str if other else False

    def __hash__(self):
        return hash(self._str)

    def action(self):
        self._action(self)

    def _getmarked(self):
        return self._marked

    def _setmarked(self, val):
        if self._marked != val:
            self._marked = val
            self._owner._item_state_changed(self._idx, val)

    marked = property(_getmarked, _setmarked)

    def __unicode__(self):
        return self._str

    def _mark_str(self):
        if not self._owner.has_marked():
            return ''
        return u'[%s] ' % (u'x' if self.marked else u' ')

    def screen_str(self):
        return self._mark_str() + unicode(self)

    def result_str(self):
        return self._str

class FileItem(Item):
    def __init__(self, str, action, attr, suffix):
        Item.__init__(self, str, action, attr)
        self._suffix = suffix
        self._dirname = getcwd()

    def __eq__(self, other):
        if not other:
            return False
        return (self._str == other._str and
                self._dirname == other._dirname)

    def __hash__(self):
        return hash(self._str) + hash(self._dirname)

    def __unicode__(self):
        if getcwd() == self._dirname:
            return self._str
        else:
            return os.path.join(self._dirname, self._str)

    def screen_str(self):
        return Item.screen_str(self) + self._suffix

    def result_str(self):
        return os.path.join(self._dirname, self._str)

class Link(FileItem):
    def __init__(self, str, action):
        FileItem.__init__(self, str, action, Attrs.LINK, u'@')
        self._to = os.readlink(self.result_str())

    def screen_str(self):
        return u'%s -> %s' % (FileItem.screen_str(self), self._to)

class Items:
    def __init__(self, items):
        self._set_items(items)
        self.item_changed_event = []
        self.has_marked_event = []

    def has_marked(self):
        return self._nmarked != 0

    def index(self, val):
        return self._items.index(val)

    def _set_items(self, items):
        self._items = items
        for idx, item in enumerate(items):
            item._owner = self
            item._idx = idx
        self._nmarked = sum(int(item.marked) for item in items)

    def remove(self, items):
        for idx in reversed(list(items)):
            del self._items[idx]
        self._set_items(self._items)

    def remove_items(self, items):
        s = set(items)
        for idx, item in reversed(list(enumerate(self._items))):
            if item in s:
                del self._items[idx]
        self._set_items(self._items)

    def _item_state_changed(self, idx, val):
        nmarked = self._nmarked
        self._nmarked += 1 if val else -1

        for listener in self.item_changed_event:
            listener(idx)
        if not nmarked or not self._nmarked:
            for listener in self.has_marked_event:
                listener()

    def __len__(self):
        return len(self._items)

    def __getitem__(self, idx):
        return self._items[idx]

class TermSize:
    """Holds the size of the terminal window."""
    @classmethod
    def init(cls):
        """Recalculates the size of the terminal window."""
        cls.height, cls.width = struct.unpack("hhhh", fcntl.ioctl(sys.__stdout__, termios.TIOCGWINSZ, "\000"*8))[0:2]

class Status:
    def __init__(self):
        self.msg = None
        self._win = None

    def _put(self, str, attr):
        if not self._win:
            self._win = curses.newwin(1, TermSize.width, TermSize.height - 1, 0)
        self._win.move(0, 0)
        self._win.clrtoeol()
        self._win.attrset(attr)
        self._win.addstr(fromuni(str[:TermSize.width - 1]))
        self._win.refresh()

    def update(self, str):
        if self.msg:
            self._put(self.msg, Attrs.MESSAGE)
        else:
            self._put(str, Attrs.STATUS)

    def query(self, str):
        str += u' '
        self._put(str, Attrs.STATUS)
        win = curses.newwin(1, TermSize.width - len(str), TermSize.height - 1, len(str))
        return curses.textpad.Textbox(win).edit().strip()

class ScrollingList:
    def __init__(self, owner, nitems, lines, idx, offset):
        self.nitems = nitems
        self.lines = lines
        self.owner = owner
        self.idx = self._bound_idx(idx)
        self.offset = offset
        self._fix_offset()

    def _bound_idx(self, idx):
        return max(0, min(idx, self.nitems - 1))

    def _bound_offset(self, offset):
        return max(0, min(offset, self.nitems - self.lines))

    def _fix_offset(self):
        if not self.contains_line(self.idx):
            if self.idx < self.offset:
                self.offset = self.idx
            else:
                self.offset = self.idx - self.lines + 1

        self.offset = self._bound_offset(self.offset)

    def __unicode__(self):
        nvisible_items = min(self.nitems - self.offset, self.lines)
        return u'%d-%d of %d' % (self.offset + 1, self.offset + nvisible_items, self.nitems)

    def contains_line(self, line):
        return self.offset <= line < self.offset + self.lines

    def visible_lines(self):
        return xrange(self.offset, self.offset + self.lines)

    def change_size(self, nitems):
        self.nitems = nitems
        self.idx = self._bound_idx(self.idx)
        self._fix_offset()

    def change_item(self, arg):
        previdx, prevoffset = self.idx, self.offset

        self.idx = self._bound_idx(arg)
        self._fix_offset()

        diff = self.offset - prevoffset

        if -1 <= diff <= 1:
            self.owner.scr.scroll(diff)
            self.owner.draw_item(previdx)
            self.owner.draw_item(self.idx)
        else:
            self.owner.redraw()

    def next_page(self):
        if self.idx - self.offset == self.lines - 1:
            self.change_item(self.idx + self.lines)
        else:
            self.change_item(self.offset + self.lines - 1)

    def prev_page(self):
        if self.idx == self.offset:
            self.change_item(self.idx - self.lines)
        else:
            self.change_item(self.offset)

def simple_factory(owner, str):
    def defaction(item):
        if not owner.has_marked():
            owner.accept_selection()
        else:
            item.marked = not item.marked

    return Item(str, defaction)

def filesystem_factory(owner, path):
    def defaction(item):
        if not owner.has_marked():
            owner.accept_selection()
        else:
            item.marked = not item.marked

    def diraction(item):
        dir = unicode(item)
        if dir == touni(os.pardir):
            owner.up_dir()
        else:
            owner.read_dir(dir)

    if os.path.isdir(fromuni(path)):
        if os.path.islink(fromuni(path)):
            return Link(path, diraction)
        else:
            return FileItem(path, diraction, Attrs.DIR, u'/')
    elif os.access(fromuni(path), os.X_OK):
        return FileItem(path, defaction, Attrs.EXEC, u'*')
    elif os.path.islink(fromuni(path)):
        return Link(path, defaction)
    else:
        return FileItem(path, defaction, Attrs.DEFAULT, u'')

class ResizeError(Exception):
    """Is raised when the terminal has been resized."""
    def __init__(self):
        Exception.__init__(self)

class InvocationError(Exception):
    """Is raised when the user requests to run an external program."""
    def __init__(self, cmd, wait_for_keypress):
        Exception.__init__(self)
        self.cmd = cmd
        self.wait_for_keypress = wait_for_keypress

class PagerError(Exception):
    """Is raised when the user requests to run the pager program."""
    def __init__(self, str):
        Exception.__init__(self, str)

class FatalError(Exception):
    """Is raised then a fatal error has occurred."""
    def __init__(self, exit_status, msg):
        self._msg = msg
        self.exit_status = exit_status

    def __unicode__(self):
        return self._msg

class StrHighlighter:
    def __init__(self, str):
        self.str = str

    def __call__(self, str, start):
        idx = str.lower().find(self.str, start)
        if idx == -1:
            return -1, -1
        return idx, idx + len(self.str)

class RegexHighlighter:
    def __init__(self, regex):
        self.regex = regex

    def __call__(self, str, start):
        match = self.regex.search(str[start:])
        if not match:
            return -1, -1
        return start + match.start(), start + match.end()

class Closure:
    def __init__(self, func, args):
        self._func = func
        self._args = args
        self._help = u'%s %s' % (func._help, str(args) if args else u'')

    def __call__(self):
        self._func(**dict(self._args))

    def __eq__(self, other):
        return self._func == other._func and self._args == other._args

    def __hash__(self):
        return hash(self._func)

    def __repr__(self):
        return repr([self._func.__name__] + self._args)[1:-1]

class Bindings:
    """Keybindings manager and serializer/deserializer."""

    BINDINGS_SECTION = 'bindings'
    BROWSER_BINDINGS_SECTION = 'browser-bindings'

    def __init__(self, owner, browser_mode):
        cfg_file = os.path.expanduser(CONFIG_FILE)

        try:
            if not os.path.isfile(cfg_file):
                raise Exception(u'file not found')
            cfg = self._create_parser()
            cfg.read(cfg_file)

            bindings = self._read_bindings(owner, cfg.items(self.BINDINGS_SECTION))
            browser_bindings = self._read_bindings(owner, cfg.items(self.BROWSER_BINDINGS_SECTION))
        except Exception, e:
            bindings = self._default_bindings(owner)
            browser_bindings = self._browser_bindings(owner)
            owner.status.msg = u'Can not load configuration file %s: %s' % (cfg_file, e)

        if not os.path.isfile(cfg_file):
            try:
                self._save_bindings(cfg_file, bindings, browser_bindings)
            except Exception, e:
                owner.status.msg = u'Can not save settings to %s: %s' % (cfg_file, e )

        self._bindings = defaultdict(list)
        self._bindings.update(bindings)
        if browser_mode:
            self._merge_bindings(browser_bindings)
        self._map = dict([(key, func) for func, keys in self._bindings.items() for key in keys])

    def _create_parser(self):
        parser = RawConfigParser()
        parser.optionxform = lambda s: s
        return parser

    def _default_bindings(self, owner):
        return {
            owner.next_item:           [Keys.DOWN, u'J', Keys.CTRL_N],
            owner.prev_item:           [Keys.UP, Keys.CTRL_P, u'K'],
            owner.next_page:           [Keys.PAGE_DOWN, Keys.CTRL_F, u'H'],
            owner.prev_page:           [Keys.PAGE_UP, Keys.CTRL_B, u'L'],
            owner.first_item:          [Keys.HOME, u'<'],
            owner.last_item:           [Keys.END, u'>'],
            owner.remove_marked:       [Keys.DELETE, u'X'],
            owner.toggle_item:         [Keys.INSERT, u' '],
            owner.invert_marks:        [u'~'],
            owner.mark_all:            [u'*'],
            owner.show_marked:         [Keys.TAB],
            owner.goto_line:           [u'G'],
            owner.mark_by_regex:       [u'%'],
            owner.filter_by_regex:     [u'/'],
            owner.redraw:              [Keys.CTRL_L],
            owner.show_bindings:       [Keys.F1, u'?', u'H'],
            owner.return_none:         [Keys.CTRL_X, u'Q'],
            owner.accept_selection:    [Keys.F10, Keys.CTRL_D, u'D'],
            owner.current_item_action: [Keys.RETURN],
            owner.query_run_command:   [u'!'],
            owner.invoke_shell:        [u'$'],
            owner.restore_items:       [Keys.ESCAPE, Keys.BACKSPACE, Keys.CTRL_H, u'^'],
            owner.invoke_pager:        [Keys.F3],
            owner.invoke_editor:       [Keys.F4],
            Closure(owner.run_command_on_current_item, [('cmd', 'cygstart'), ('wait_for_keypress', False)]): [Keys.F2],
            Closure(owner.run_command, [('cmd', 'ls -la')]): [Keys.F5],
            Closure(owner.run_command, [('cmd', 'du -chs')]): [Keys.F6],
            Closure(owner.run_command, [('cmd', 'rm -fr'), ('wait_for_keypress', False)]): [Keys.F8],}

    def _browser_bindings(self, owner):
        return {
            owner.restore_or_up_dir:   [Keys.BACKSPACE, Keys.CTRL_H, u'^'],
            owner.reread_dir:          [Keys.CTRL_R, u'R'],
            owner.query_chdir:         [u'C'],}

    def _read_bindings(self, owner, bindings):
        res = {}
        for func, keys in bindings:
            args = eval(func)
            if type(args) != tuple:
                args = (args,)
            res[Closure(getattr(owner, args[0]), args[1:])] = [Keys.code(key.strip()) for key in keys.split(',')]
        return res

    def _save_bindings(self, cfg_file, bindings, browser_bindings):
        cfg = self._create_parser()
        self._dump_bindings(cfg, self.BINDINGS_SECTION, bindings)
        self._dump_bindings(cfg, self.BROWSER_BINDINGS_SECTION, browser_bindings)
        cfg.write(open(cfg_file, 'w'))

    def _func_name(self, func):
        if type(func) == types.MethodType:
            return repr(func.__name__)
        else:
            # assuming Closure here...
            return repr(func)

    def _dump_bindings(self, cfg, section, bindings):
        cfg.add_section(section)
        b = [(self._func_name(func), keys) for func, keys in bindings.items()]

        for func, keys in sorted(b, key=fst):
            cfg.set(section, func, ', '.join(map(Keys.str, keys)))

    def _merge_bindings(self, bindings):
        newkeys = set()
        for keys in bindings.itervalues():
            newkeys |= set(keys)

        for func in self._bindings:
            keys = set(self._bindings[func]) - newkeys
            self._bindings[func] = keys

        self._bindings = defaultdict(list, filter(lambda x: x[1], self._bindings.items()))

        for func, keys in bindings.items():
            curkeys = set(self._bindings[func])
            curkeys.update(set(keys))
            self._bindings[func] = list(curkeys)

    def __contains__(self, key):
        return key in self._map

    def __getitem__(self, key):
        return self._map[key]

    def show(self):
        lines = []
        for binding, keys in sorted(self._bindings.items(), key=lambda key: key[0]._help):
            lines.append((u', '.join(sorted(map(Keys.str, keys))), binding._help))
        width = max(len(line[0]) for line in lines) + 1

        raise PagerError('''
Just start typing to narrow down the list. Other keybindings:

%s

Basic customization is available via %s (currently not very human-friendly, sorry).
Press any key to continue...''' % (u'\n'.join(line[0].ljust(width) + line[1] for line in lines), CONFIG_FILE))

class Timer:
    def __init__(self):
        self.reset()

    def reset(self):
        self._time = time.time()

    def elapsed(self):
        return time.time() - self._time

def helpmsg(str):
    """Decorator which adds a description to the function, which is
    then used in the bindings list."""
    def decorator(func):
        func._help = str
        return func
    return decorator

class Screen:
    """Main application class."""

    def __init__(self, scr, factory, matches, browser_mode):
        self.scr = scr
        self.scr.scrollok(1)
        self._factory = factory
        self._marked_items = []
        self._resized = False
        self._highlighter = None
        self.list = None
        self.status = Status()
        self.bindings = Bindings(self, browser_mode)
        self.update_list = self.reread_dir if browser_mode else lambda: None
        self._create_items(matches)

    def _create_items(self, elems):
        newitems = [self._factory(self, e) for e in elems]
        marked = self._marked_items

        for idx, item in enumerate(newitems):
            if item in marked:
                newitems[idx] = marked[marked.index(item)]

        self._set_items(newitems)
        self._allitems = None

    def _update_list(self, idx = 0, offset = 0):
        self.list = ScrollingList(self, len(self.items), TermSize.height - 1, idx, offset)
        self.redraw()

    def has_marked(self):
        return bool(self._marked_items)

    def _set_items(self, items):
        self.items = Items(items)
        self.items.item_changed_event.append(self.draw_item)
        self.items.item_changed_event.append(self._update_marked_items_list)
        self.items.has_marked_event.append(self.redraw)

    def _getch(self):
        self.scr.timeout(100)
        try:
            res = self.scr.getkey()
            self.scr.timeout(0)
            while True:
                try:
                    res += self.scr.getkey()
                except:
                    return touni(res)
        except:
            return u''

    def _highlightstr(self, y, x, attr, s):
        idx = 0
        ls = s.lower()
        while idx < len(s):
            start = -1
            if self._highlighter:
                start, end = self._highlighter(s, idx)
            if start == -1:
                self.scr.attrset(attr)
                self.scr.addstr(y, x + idx, fromuni(s[idx:]))
                break
            else:
                self.scr.attrset(attr)
                self.scr.addstr(y, x + idx, fromuni(s[idx:start]))

                self.scr.attrset(Attrs.HIGHLIGHT)
                self.scr.addstr(y, x + start, fromuni(s[start:end]))

                idx = end

        self.scr.attrset(attr)

    def draw_item(self, idx, refresh = True):
        if self._resized or idx >= len(self.items) or not self.list.contains_line(idx):
            return

        y = idx - self.list.offset
        line_num = str(idx + 1).rjust(len(str(len(self.items)))) + u' '
        item = self.items[idx]
        s = item.screen_str()

        self.clear_line(y)
        self.scr.attrset(Attrs.LINENUM)
        self.scr.addstr(y, 0, line_num[:TermSize.width])

        if self.list.idx == idx:
            attr = Attrs.SELECTED
        elif item.marked:
            attr = Attrs.MARKED
        else:
            attr = item.attr

        s = s.ljust(TermSize.width - len(line_num))
        self._highlightstr(y, len(line_num), attr, s[:TermSize.width - len(line_num)])

        if refresh:
            self.scr.refresh()

    def _update_marked_items_list(self, idx):
        item = self.items[idx]
        if item.marked:
            self._marked_items.append(item)
        else:
            self._marked_items.remove(item)

    def clear_line(self, line):
        self.scr.move(line, 0)
        self.scr.clrtoeol()

    @helpmsg(u'redraw')
    def redraw(self):
        for curidx in self.list.visible_lines():
            if curidx < len(self.items):
                self.draw_item(curidx, False)
            else:
                self.clear_line(curidx - self.list.offset)
        self.scr.refresh()

    def current_item(self):
        return self.items[self.list.idx] if self.items else None

    @helpmsg(u'perform action on the current item')
    def current_item_action(self):
        return self.current_item().action()

    @helpmsg(u'toggle mark on selected item')
    def toggle_item(self):
        item = self.current_item()
        item.marked = not item.marked

    @helpmsg(u'invert marks')
    def invert_marks(self):
        for item in self.items:
            item.marked = not item.marked

    @helpmsg(u'mark all items')
    def mark_all(self):
        for item in self.items:
            item.marked = True

    def update_status(self):
        curdir = getcwd()
        self.status.update(curdir + unicode(self.list).rjust(TermSize.width - len(curdir) - 1))

    @helpmsg(u'goto line')
    def goto_line(self):
        linestr = self.status.query(u'Goto line:')
        try:
            line = int(linestr)
        except ValueError:
            self.status.msg = u'Invalid line number!'
            return
        self.list.change_item(line - 1)

    @helpmsg(u'mark by regexp')
    def mark_by_regex(self):
        s = self.status.query(u'Mark by regex:')
        try:
            regex = re.compile(s.strip(), re.IGNORECASE)
        except Exception, e:
            self.status.msg = u'Invalid regexp: %s' % e
            return

        for item in self.items:
            if regex.search(unicode(item)):
                item.marked = True

    def _filter(self, items):
        if not items:
            self.redraw()
            self.status.msg = u'No matches!'
            return False
        if not self._allitems:
            self._allitems = self.items
        self._set_items(list(items))
        self._update_list()
        return True

    def _items_by_pattern(self, pat):
        for item in self.items:
            if pat in unicode(item).lower():
                yield item

    def _items_by_regex(self, regex):
        for item in self.items:
            if regex.search(unicode(item).lower()):
                yield item

    def filter_by_pattern(self, pattern):
        self._highlighter = StrHighlighter(pattern)
        return self._filter(list(self._items_by_pattern(pattern)))

    @helpmsg(u'filter the list by regexp')
    def filter_by_regex(self):
        s = self.status.query(u'Search by regex:')
        if not s:
            return False

        try:
            regex = re.compile(s.strip(), re.IGNORECASE)
        except Exception, e:
            self.status.msg = u'Invalid regexp: %s' % e
            return

        self._highlighter = RegexHighlighter(regex)
        return self._filter(list(self._items_by_regex(regex)))

    @helpmsg(u'show only marked items')
    def show_marked(self):
        self.restore_items()
        self._clear_highlighter()
        self._filter(self._marked_items)

    def _enumerate_selected(self):
        if not self.items:
            return
        if self.items.has_marked():
            for idx, item in enumerate(self.items):
                if item.marked:
                    yield (idx, item)
        else:
            yield (self.list.idx, self.current_item())

    @helpmsg(u'remove marked items')
    def remove_marked(self):
        toremove = set(item for _, item in self._enumerate_selected())
        if self._allitems:
            self._allitems.remove_items(toremove)

        self._marked_items = filter(lambda item: not item in toremove, self._marked_items)
        self.items.remove(idx for idx, _ in self._enumerate_selected())
        self._update_list(self.list.idx, self.list.offset)

    def read_dir(self, dir):
        try:
            entries = listdir_sorted(dir)
            os.chdir(fromuni(dir))
        except OSError, e:
            self.status.msg = u'Can\'t read dir %s: %s' % (dir, e)
        else:
            self._create_items(entries)
            self._update_list()

    @helpmsg(u'change working directory')
    def query_chdir(self):
        dir = self.status.query(u'Change dir to:')
        dir = os.path.expandvars(os.path.expanduser(dir))
        self.read_dir(dir)

    def up_dir(self):
        (parent, cur) = os.path.split(getcwd())
        self.read_dir(parent)

        for idx, item in enumerate(self.items):
            if unicode(item) == cur:
                self.list.change_item(idx)

    @helpmsg(u'reread contents of the current directory')
    def reread_dir(self):
        cur = None
        if self.items:
            cur = unicode(self.current_item())
            curidx = self.list.idx

        self.read_dir(getcwd())

        if not cur:
            return

        for idx, item in enumerate(self.items):
            if unicode(item) == cur:
                self.list.change_item(idx)
                break

        self.list.change_item(curidx)

    @helpmsg(u'reset current filter')
    def restore_items(self):
        if self.pattern:
            return
        if not self._allitems:
            return
        cur = self.current_item()
        self._set_items(self._allitems)
        self._update_list(self.items.index(cur) if cur in self.items else 0)
        self._allitems = None

    @helpmsg(u'reset current pattern or filter if any or go to the parent directory')
    def restore_or_up_dir(self):
        if self._allitems:
            self.restore_items()
        else:
            self.up_dir()

    def _set_result(self, res):
        self._result = res

    @helpmsg(u'exit from the program and return marked items')
    def accept_selection(self):
        if self.has_marked():
            self._set_result([item.result_str() for item in self._marked_items])
        else:
            self._set_result([self.current_item().result_str()])

    @helpmsg(u'exit the program not returning anything')
    def return_none(self):
        return self._set_result([])

    # @helpmsg(u'exit with the name of the current working directory as the only result')
    # def return_pwd(self):
    #     return self._set_result([getcwd()])

    @helpmsg(u'scroll one page down')
    def next_page(self):
        self.list.next_page()

    @helpmsg(u'scroll one page up')
    def prev_page(self):
        self.list.prev_page()

    @helpmsg(u'goto next line')
    def next_item(self):
        self.list.change_item(self.list.idx + 1)

    @helpmsg(u'goto prev item')
    def prev_item(self):
        self.list.change_item(self.list.idx - 1)

    @helpmsg(u'goto first item in the list')
    def first_item(self):
        self.list.change_item(0)

    @helpmsg(u'goto last item in the list')
    def last_item(self):
        self.list.change_item(len(self.items) - 1)

    @helpmsg(u'show this help')
    def show_bindings(self):
        self.clear_screen()
        self.bindings.show()

    def clear_screen(self):
        self.scr.clear()
        self.scr.refresh()

    def resize(self, *args):
        self._resized = True

    @helpmsg(u'invoke shell')
    def invoke_shell(self):
        self.clear_screen()
        raise InvocationError(shell_path(), False)

    @helpmsg(u'invoke pager on the current item')
    def invoke_pager(self):
        self.run_command_on_items(pager_name(), [self.current_item()], False)

    @helpmsg(u'invoke editor on the current item')
    def invoke_editor(self):
        self.run_command_on_items(editor_name(), [self.current_item()], False)

    @helpmsg(u'run command')
    def run_command(self, cmd, wait_for_keypress=True):
        items = self._marked_items or [self.current_item()]
        self.run_command_on_items(cmd, items, wait_for_keypress)

    @helpmsg(u'run command on the current item')
    def run_command_on_current_item(self, cmd, wait_for_keypress=True):
        self.run_command_on_items(cmd, [self.current_item()], wait_for_keypress)

    def run_command_on_items(self, cmd, items, wait_for_keypress=True):
        if not cmd:
            return
        self._clear_highlighter()
        self._clear_pattern()
        self.clear_screen()
        args = map(unicode, items)
        raise InvocationError(cmd + u' ' + u' '.join(map(shell_quote, args)), wait_for_keypress)

    @helpmsg(u'run command on selection')
    def query_run_command(self):
        self.run_command(self.status.query(u'Run command on selection:'))

    def _clear_highlighter(self):
        if not self._highlighter:
            return

        self._highlighter = None
        self.redraw()

    def _clear_pattern(self):
        if not self.pattern:
            return

        self.pattern = u''
        self._clear_highlighter()

    def run(self):
        self.clear_screen()

        if not self.list:
            self._update_list()
        else:
            self._update_list(self.list.idx, self.list.offset)

        self.pattern = u''
        lastpress = Timer()

        self._result = None
        while self._result is None:
            self.update_status()

            try:
                c = self._getch()
            except KeyboardInterrupt:
                self.return_none()
                break

            if self._resized:
                self._resized = False
                raise ResizeError()

            if c in self.bindings:
                self.status.msg = None

                # TODO: the order of the function calls is significant here
                # because of filter_by_pattern and restore_items methods.
                # Some other solution should be devised.
                self._clear_highlighter()
                self.bindings[c]()
                self._clear_pattern()
            elif is_printable_char(c):
                self.status.msg = None
                self.pattern += c
                lastpress.reset()
                if not self.filter_by_pattern(self.pattern):
                    self._clear_pattern()
            elif c or lastpress.elapsed() > PATTERN_TIMEOUT:
                self._clear_pattern()

        self.clear_screen()

        return self._result

# some helper context manager for work with curses and terminal
class TTYStdinLock:
    """Context manager that connects stdin to the terminal."""
    def __enter__(self):
        self._saved_stdin = os.dup(0)
        os.close(0)
        os.open('/dev/tty', os.O_RDONLY)

    def __exit__(self, *args):
        os.close(0)
        os.dup(self._saved_stdin)

class TTYStdoutLock:
    """Context manager that connects stdout to the terminal."""
    def __enter__(self):
        self._saved_stdout = os.dup(1)
        os.close(1)
        os.open('/dev/tty', os.O_RDWR)

    def __exit__(self, *args):
        os.close(1)
        os.dup(self._saved_stdout)

class TTYLock:
    """Context manager that connects both stdin and stdout to the terminal."""
    def __init__(self):
        self.inlocker = TTYStdinLock()
        self.outlocker = TTYStdoutLock()

    def __enter__(self):
        self.inlocker.__enter__()
        self.outlocker.__enter__()

    def __exit__(self, *args):
        self.inlocker.__exit__(*args)
        self.outlocker.__exit__(*args)

class ShellModeLock:
    """Context manager for resetting curses to shell mode."""
    def __enter__(self):
        curses.reset_shell_mode()

    def __exit__(self, *args):
        curses.reset_prog_mode()

def separator(options):
    if options.null_terminated:
        return u'\x00'
    elif options.newlines:
        return u'\n'
    else:
        return touni(options.ofs)

def exec_processor(cmd, replacestr):
    if not is_executable(cmd[0]):
        raise FatalError(ExitStatuses.EXEC_ERROR, u"can not find executable program '%s' in the PATH" % touni(cmd[0]))

    cmd = map(touni, cmd)
    replacestr = touni(replacestr)

    def doexec(args):
        if replacestr:
            c = []
            for idx, arg in enumerate(cmd):
                if arg == replacestr:
                    c.extend(args)
                else:
                    c.append(arg)
        else:
            c = cmd + args

        with TTYStdinLock():
            try:
                os.execlp(c[0], *c)
            except OSError, e:
                raise FatalError(ExitStatuses.EXEC_ERROR, u"can not invoke program '%s': %s\n" % (c[0], touni(str(e))))

    return doexec

def quoting_processor(func):
    return lambda args: func(map(shell_quote, args))

def printing_processor(sep):
    return lambda args: sys.stdout.write(fromuni(sep.join(args)))

def create_processor(options, args):
    if args:
        proc = exec_processor(args, options.replacestr)
    else:
        proc = printing_processor(separator(options))
        if options.quote:
            proc = quoting_processor(proc)
    return proc

def process_args():
    parser = optparse.OptionParser(usage='usage: %prog [options] [cmd]...',
                                   version='%prog ' + str(VERSION), description=
'''Depending on whether the input is from a terminal or not, acts as a
simple directory browser, which can be used to pick a number of files,
or allows you to select from a set of options, obtained by parsing
input data using the specified regular expression. If cmd is given,
then it is run with the selected items as arguments, otherwise these
items are just printed to the standard output. Press '?' for keyboard
bindings and basic help on interactive usage. Please send bug reports
and suggestions to Igor.Akhmetov at gmail dot com.''')

    parser.add_option('-0', '--print0', action='store_true', dest='null_terminated', default=False,
                      help='separate output fields with null character')
    parser.add_option('-a', '--arg-file', action='store', type='string', dest='argfile', default=None,
                      help='read items from ARGFILE instead of standard input')
    parser.add_option('-i', '--replace', action='store', type='string', dest='replacestr', default=None,
                      help='replace occurances of REPLACESTR in the initial arguments with selected items')
    parser.add_option('-n', '--newline', action='store_true', dest='newlines', default=False,
                      help='separate output fields with newlines')
    parser.add_option('-o', '--ofs', action='store', type='string', dest='ofs', default=' ',
                      help='output fields separator, space by default')
    parser.add_option('-r', '--regexp', action='store', type='string', dest='regexp', default='^.*$',
                      help='parse input data using given regular expression')
    parser.add_option('-q', '--quote', action='store_true', dest='quote', default=False,
                      help='quote output fields')
    parser.add_option('-t', '--run-tests', action='store_true', dest='run_tests', default=False,
                      help='run doctests, for development purposes only')


    parser.disable_interspersed_args()
    (options, args) = parser.parse_args()

    return options, create_processor(options, args)

def create_reader(options):
    if options.argfile:
        return open(options.argfile).xreadlines()
    else:
        return sys.stdin.xreadlines()

def itermatches(input, regexp):
    """Iterates over all matches of the 'regexp' regular expression
    over the elements of 'input'."""
    return itertools.chain(*itertools.imap(regexp.findall, input))

def run_command(cmd, wait_for_keypress):
    """Runs program 'cmd'. If 'wait_for_keypress' is true, waits for user
    to press return afterwards."""
    with ShellModeLock():
        retcode = None

        try:
            retcode = subprocess.call(cmd, shell=True)

            if retcode < 0:
                sys.stderr.write('\nChild was terminated by signal %s' % -retcode)
            elif retcode:
                sys.stderr.write('\nChild returned %s' % retcode)
        except OSError, e:
            sys.stderr.write('\nExecution failed: %s' % e)

        if retcode != None and (retcode != 0 or wait_for_keypress):
            raw_input('\nPress ENTER to continue')

def run_pager(text):
    """Starts pager program to display given 'text'."""
    with ShellModeLock():
        try:
            pager = subprocess.Popen(pager_name(), stdin=subprocess.PIPE)
            pager.stdin.write(fromuni(text))
            pager.stdin.close()
            pager.wait()
        except OSError, e:
            sys.stderr.write(fromuni(u"Pager '%s' failed: %s" % (pager_name(), touni(str(e)))))
            raw_input('\nPress ENTER to continue')

def init_curses():
    """Performs initialization of the curses library."""
    # sometimes raises an exception in cygwin
    try:
        curses.curs_set(0)
    except:
        pass

    curses.use_default_colors()
    Attrs.init()
    ColorsManager.init()
    Keys.init()

def mainloop(factory, matches, browser_mode, wnd):
    init_curses()

    scr = Screen(wnd, factory, matches, browser_mode)
    signal.signal(signal.SIGWINCH, scr.resize)

    while True:
        try:
            TermSize.init()
            return scr.run()
        except InvocationError, e:
            run_command(e.cmd, e.wait_for_keypress)
            scr.update_list()
        except PagerError, e:
            run_pager(unicode(e))
        except ResizeError:
            pass

def main():
    try:
        cgitb.enable(format='text')
        locale.setlocale(locale.LC_ALL, '')

        options, proc = process_args()
        if options.run_tests:
            import doctest
            doctest.testmod(verbose=True, exclude_empty=True)
            return

        browser_mode = os.isatty(0) and not options.argfile
        if browser_mode:
            matches = listdir_sorted(getcwd())
            factory = filesystem_factory
        else:
            try:
                regexp = re.compile(options.regexp, re.IGNORECASE)
            except Exception, e:
                raise FatalError(ExitStatuses.INVALID_REGEXP, u"error compiling regex '%s': %s" % (touni(options.regexp), e))

            matches = list(itermatches(create_reader(options), regexp))
            factory = simple_factory

        if not matches:
            sys.exit(ExitStatuses.NOTHING_SELECTED)

        with TTYLock():
            res = curses.wrapper(lambda wnd: mainloop(factory, matches, browser_mode, wnd))

        if not res:
            sys.exit(ExitStatuses.NOTHING_SELECTED)

        proc(res)
    except FatalError, e:
        sys.stderr.write(fromuni(u'%s: %s\n' % (program_name(), unicode(e))))
        sys.exit(e.exit_status)

if __name__ == '__main__':
    main()
