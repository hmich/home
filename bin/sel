#!/usr/bin/env python

# Copyright (c) 2008 Igor Akhmetov
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

from __future__ import with_statement

import os
import os.path
import sys
import re
import string
import optparse
import logging

import curses
import curses.ascii
import curses.textpad
import curses.wrapper

VERSION = 0.1
PATTERN_TIMEOUT = 2000
NOTHING_SELECTED_EXIT_STATUS = 1

class Attrs:
    def init(cls):
        color = lambda fg, bg: curses.color_pair(ColorsManager.color(fg, bg))
        cls.DEFAULT = cls.STATUS = cls.LINENUM = color(curses.COLOR_WHITE, -1)
        cls.MARKED = cls.DEFAULT | curses.A_BOLD
        cls.SELECTED = color(curses.COLOR_WHITE, curses.COLOR_BLUE) | curses.A_BOLD
        cls.DIR = color(curses.COLOR_BLUE, -1) | curses.A_BOLD
        cls.EXEC = color(curses.COLOR_GREEN, -1 ) | curses.A_BOLD
        cls.LINK = color(curses.COLOR_CYAN, -1 ) | curses.A_BOLD
    init = classmethod(init)

class ColorsManager(object):
    _colors = []

    def init(cls):
        for (idx, (fg, bg)) in enumerate(cls._colors):
            curses.init_pair(idx, fg, bg)
    init = classmethod(init)

    def color(cls, fg, bg):
        cls._colors.append((fg, bg))
        return len(cls._colors) - 1
    color = classmethod(color)

def cyclic_xrange(start, cnt):
    for idx in xrange(start, cnt):
        yield idx
    for idx in xrange(start):
        yield idx

def listdir_sorted(dir):
    entries = sorted((f for f in os.listdir(dir)), key=string.lower)
    dirs = [f for f in entries if os.path.isdir(os.path.join(dir, f))]
    files = [f for f in entries if os.path.isfile(os.path.join(dir, f))]
    return dirs + files

class Item(object):
    def __init__(self, str, action):
        self._str = str
        self._marked = False
        self.action = action

    def _getmarked(self):
        return self._marked

    def _setmarked(self, val):
        if self._marked != val:
            self._marked = val
            self._owner._item_state_changed(self._idx, val)

    marked = property(_getmarked, _setmarked)

    def __str__(self):
        return self._str

    def _mark_str(self):
        if not self._owner.has_marked():
            return ''
        return '[%s] ' % ('x' if self.marked else ' ')

    def screen_str(self):
        return self._mark_str() + str(self)

    def attr(self):
        return Attrs.DEFAULT

class Dir(Item):
    def __init__(self, str, action):
        Item.__init__(self, str, action)

    def screen_str(self):
        return Item.screen_str(self) + '/'

    def attr(self):
        return Attrs.DIR

class Link(Item):
    def __init__(self, str, action):
        Item.__init__(self, str, action)

    def screen_str(self):
        return Item.screen_str(self) + '@'

    def attr(self):
        return Attrs.LINK

class DirLink(Link):
    def __init__(self, str, action):
        Link.__init__(self, str, action)

    def screen_str(self):
        return Item.screen_str(self) + '/@'

class Executable(Item):
    def __init__(self, str, action):
        Item.__init__(self, str, action)

    def screen_str(self):
        return Item.screen_str(self) + '*'

    def attr(self):
        return Attrs.EXEC

class Items:
    def __init__(self, items):
        self._set_items(items)
        self.item_changed_event = []
        self.has_marked_event = []

    def has_marked(self):
        return self._nmarked > 0

    def _set_items(self, items):
        self._items = items
        for (idx, item) in enumerate(items):
            item._owner = self
            item._idx = idx
        self._nmarked = sum(int(item.marked) for item in items)

    def remove(self, items):
        for idx in reversed(list(items)):
            del self._items[idx]
        self._update_data()

    def insert(self, idx, matches):
        newitems = [Item(match, self) for match in matches]
        self._set_items(self._items[:idx] + newitems + self._items[idx:])

    def _item_state_changed(self, idx, val):
        nmarked = self._nmarked
        self._nmarked += 1 if val else -1

        for listener in self.item_changed_event:
            listener(idx)
        if not nmarked or not self._nmarked:
            for listener in self.has_marked_event:
                listener()

    def __len__(self):
        return len(self._items)

    def __getitem__(self, idx):
        return self._items[idx]

class Status:
    def __init__(self):
        self.win = curses.newwin(1, curses.COLS, curses.LINES - 1, 0)
        self.win.attrset(Attrs.STATUS)

    def clear(self):
        self.win.move(0, 0)
        self.win.clrtoeol()

    def put(self, str):
        self.clear()
        self.win.addstr(str)
        self.win.refresh()

    def query(self, str):
        str += ' '
        self.put(str)
        win = curses.newwin(1, curses.COLS - len(str), curses.LINES - 1, len(str))
        return curses.textpad.Textbox(win).edit()

class ScrollingList:
    def __init__(self, owner, nitems, lines, idx, offset):
        self.nitems = nitems
        self.lines = lines
        self.owner = owner
        self.offset = self._bound_offset(offset)
        self.idx = self._bound_idx(idx)

    def _bound_idx(self, idx):
        return max(0, min(idx, self.nitems - 1))

    def _bound_offset(self, offset):
        return max(0, min(offset, self.nitems - self.lines))

    def __str__(self):
        nvisible_items = min(self.nitems - self.offset + 1, self.lines)
        return "%d-%d of %d" % (self.offset + 1, self.offset + nvisible_items, self.nitems)

    def contains_line(self, line):
        return self.offset <= line < self.offset + self.lines

    def visible_lines(self):
        return xrange(self.offset, self.offset + self.lines)

    def change_size(self, nitems):
        self.nitems = nitems
        self.offset = self._bound_offset(self.offset)
        self.idx = self._bound_idx(self.idx)

    def change_item(self, arg):
        previdx, prevoffset = self.idx, self.offset

        self.idx = self._bound_idx(arg)
        if not self.contains_line(self.idx):
            if self.idx < self.offset:
                self.offset = self.idx
            else:
                self.offset = self.idx - self.lines + 1

        self.offset = self._bound_offset(self.offset)

        if self.offset == prevoffset:
            self.owner.draw_item(previdx)
            self.owner.draw_item(self.idx)
        else:
            self.owner.redraw()

    def next_page(self):
        if self.idx - self.offset == self.lines - 1:
            self.change_item(self.idx + self.lines)
        else:
            self.change_item(self.offset + self.lines - 1)

    def prev_page(self):
        if self.idx == self.offset:
            self.change_item(self.idx - self.lines)
        else:
            self.change_item(self.offset)

def simple_factory(owner, str):
    return Item(str, owner.accept_selection)

def filesystem_factory(owner, str):
    path = os.path.join(owner.dir, str)

    if os.path.isdir(path):
        def expand_dir():
            if not owner.items.has_marked():
                owner.read_dir(str)
            else:
                owner.accept_selection()
        if os.path.islink(path):
            return DirLink(str, expand_dir)
        else:
            return Dir(str, expand_dir)
    elif os.access(path, os.X_OK):
        return Executable(str, owner.accept_selection)
    elif os.path.islink(path):
        return Link(str, owner.accept_selection)
    else:
        return Item(str, owner.accept_selection)

class Screen:
    def __init__(self, factory, matches):
        self.dir = os.getcwd()
        self.factory = factory
        self.items = self._create_items(matches)

    def _create_items(self, elems):
        res = Items([self.factory(self, e) for e in elems])
        res.item_changed_event.append(self.draw_item)
        res.has_marked_event.append(self.redraw)
        return res

    def getch(self):
        self.scr.timeout(PATTERN_TIMEOUT)
        return self.scr.getch()

    def draw_item(self, idx, refresh = True):
        if idx >= len(self.items) or not self.list.contains_line(idx):
            return

        y = idx - self.list.offset
        line_num = str(idx + 1).rjust(len(str(len(self.items))) + 1) + ' '
        item = self.items[idx]
        s = item.screen_str()

        self.clear_line(y)
        self.scr.attrset(Attrs.LINENUM)
        self.scr.addstr(y, 0, line_num)

        if self.list.idx == idx:
            attr = Attrs.SELECTED
        elif item.marked:
            attr = Attrs.MARKED
        else:
            attr = item.attr()

        self.scr.attrset(attr)
        self.scr.addstr(y, len(line_num), s + ' ' * (curses.COLS - len(s) - len(line_num)))
        if refresh:
            self.scr.refresh()

    def clear_line(self, line):
        self.scr.move(line, 0)
        self.scr.clrtoeol()

    def redraw(self):
        for curidx in self.list.visible_lines():
            if curidx < len(self.items):
                self.draw_item(curidx, False)
            else:
                self.clear_line(curidx - self.list.offset)
        self.scr.refresh()

    def current_item(self):
        return self.items[self.list.idx]

    def toggle_item(self):
        item = self.current_item()
        item.marked = not item.marked

    def invert_selection(self):
        for item in self.items:
            item.marked = not item.marked

    def select_all(self):
        for item in self.items:
            item.marked = True

    def update_status(self):
        self.status.put(self.dir + str(self.list).rjust(curses.COLS - len(self.dir) - 1))

    def goto_line(self):
        linestr = self.status.query("Goto line:")
        try:
            line = int(linestr)
        except ValueError:
            return
        self.list.change_item(line - 1)

    def mark_by_regex(self):
        s = self.status.query("Mark by regex:")
        try:
            regex = re.compile(s.strip(), re.IGNORECASE)
        except:
            return

        for item in self.items:
            if regex.search(str(item)):
                item.marked = True

    def _focus_pattern(self, startidx):
        for idx in cyclic_xrange(startidx, len(self.items)):
            if self.pattern in str(self.items[idx]).lower():
                self.list.change_item(idx)
                break

    def _focus_regex(self, startidx):
        for idx in cyclic_xrange(startidx, len(self.items)):
            if self.regex.search(str(self.items[idx])):
                self.list.change_item(idx)
                break

    def focus_pattern(self, pat):
        self.regex = None
        self.pattern = pat
        self._focus_pattern(self.list.idx)

    def search_by_regex(self):
        s = self.status.query("Search by regex:")
        try:
            self.regex = re.compile(s.strip(), re.IGNORECASE)
        except:
            return

        self.pattern = None
        self._focus_regex(self.list.idx)

    def next_match(self):
        if self.pattern:
            self._focus_pattern(self.list.idx + 1)
        elif self.regex:
            self._focus_regex(self.list.idx + 1)

    def enumerate_selected(self):
        if self.items.has_marked():
            for (idx, item) in enumerate(self.items):
                if item.marked:
                    yield (idx, item)
        else:
            yield (self.list.idx, self.current_item())

    def _update_list(self, idx = 0, offset = 0):
        self.list = ScrollingList(self, len(self.items), curses.LINES - 1, idx, offset)
        self.redraw()

    def remove_marked(self):
        self.items.remove(idx for (idx, _) in self.enumerate_selected())
        if not self.items:
            return
        self._update_list(self.list.idx, self.list.offset)

    def init_curses(self):
        curses.use_default_colors()
        Attrs.init()
        ColorsManager.init()

        # sometimes raises an exception in cygwin
        try:
            curses.curs_set(0)
        except:
            pass

    def is_dir(self, idx = None):
        idx = idx or self.list.idx
        return os.path.isdir(os.path.join(self.dir, str(self.items[idx])))

    def expand_dir(self):
        if not self.is_dir():
            return

        dir = str(self.current_item())
        items = [os.path.join(dir, f) for f in listdir_sorted(dir)]
        self.items.insert(self.list.idx + 1, items)
        self._update_list(self.list.idx, self.list.offset)

    def read_dir(self, dir):
        if not os.path.isabs(dir):
            dir = os.path.join(self.dir, dir)

        entries = listdir_sorted(dir)

        self.dir = os.path.abspath(dir)
        self.items = self._create_items(entries)
        self._update_list()

    def up_dir(self):
        (parent, cur) = os.path.split(self.dir)
        self.read_dir(parent)
        for (idx, item) in enumerate(self.items):
            if str(item) == cur:
                self.list.change_item(idx)

    def set_result(self, res):
        self.result = res;

    def accept_selection(self):
        self.set_result([item for (_, item) in self.enumerate_selected()])

    next_page  = lambda self: self.list.next_page()
    prev_page  = lambda self: self.list.prev_page()
    next_item  = lambda self: self.list.change_item(self.list.idx + 1)
    prev_item  = lambda self: self.list.change_item(self.list.idx - 1)
    first_item = lambda self: self.list.change_item(0)
    last_item  = lambda self: self.list.change_item(len(self.items) - 1)

    def mainloop(self, stdscr):
        self.init_curses()
        self.status = Status()
        self.scr = stdscr
        self._update_list()

        bindings = {
            curses.KEY_DOWN:      self.next_item,
            ord('J'):             self.next_item,
            14:                   self.next_item, # Ctrl-N
            curses.KEY_UP:        self.prev_item,
            ord('K'):             self.prev_item,
            16:                   self.prev_item, # Ctrl-P
            curses.KEY_NPAGE:     self.next_page,
            ord('H'):             self.next_page,
            6:                    self.next_page, # Ctrl-F
            curses.KEY_PPAGE:     self.prev_page,
            ord('L'):             self.prev_page,
            2:                    self.prev_page, # Ctrl-B
            curses.KEY_HOME:      self.first_item,
            ord('<'):             self.first_item,
            curses.KEY_END:       self.last_item,
            ord('>'):             self.last_item,
            curses.KEY_DC:        self.remove_marked,
            ord('D'):             self.remove_marked,
            curses.KEY_IC:        self.toggle_item,
            ord(' '):             self.toggle_item,
            ord('!'):             self.invert_selection,
            ord('*'):             self.select_all,
            ord('G'):             self.goto_line,
            ord('%'):             self.mark_by_regex,
            ord('/'):             self.search_by_regex,
            ord('N'):             self.next_match,
            curses.KEY_BACKSPACE: self.up_dir,
            ord('^'):             self.up_dir,
            ord('I'):             self.expand_dir,
            9:                    self.expand_dir, # Ctrl-I
            4:                    lambda: self.set_result([self.dir]), # Ctrl-D
            ord('\n'):            lambda: self.current_item().action(),
        }

        pattern = ''
        self.result = None
        while self.items and self.result == None:
            self.update_status()

            try:
                c = self.getch()
            except KeyboardInterrupt:
                break

            if bindings.get(c):
                bindings[c]()
                pattern = ''
            elif curses.ascii.isprint(c):
                pattern += chr(c)
                self.focus_pattern(pattern)

        self.scr.clear()
        self.scr.refresh()

        return map(lambda x: os.path.join(self.dir, str(x)), self.result or [])

class TTYLocker:
    def __enter__(self):
        self._saved_stdin = os.dup(0)
        self._saved_stdout = os.dup(1)

        os.close(0)
        os.close(1)

        os.open('/dev/tty', os.O_RDONLY)
        os.open('/dev/tty', os.O_RDWR)

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.close(0)
        os.close(1)

        os.dup(self._saved_stdin)
        os.dup(self._saved_stdout)

def process_args():
    parser = optparse.OptionParser(usage='usage: %prog [options] [regexp]...', version='%prog ' + str(VERSION), description=
'''Allows you to quickly select from a number of options,
including filenames and strings parsed from the standard input using regexps.''')

    parser.add_option('-0', '--print0', action='store_true', dest='null_terminated', default=False, help='separate output items with null character')
    parser.add_option('-o', '--ofs', action='store', type='string', dest='ofs', default=' ', help='output fields separator, space by default')

    (options, args) = parser.parse_args()
    args = args or ['^.*$']

    return options, [re.compile(s, re.IGNORECASE) for s in args]

def itermatches(regexps):
    for line in sys.stdin.xreadlines():
        for re in regexps:
            for match in re.findall(line):
                yield match

def separator(options):
    return '\x00' if options.null_terminated else options.ofs

def main():
    options, regexps = process_args()
    if os.isatty(0):
        matches = listdir_sorted(os.getcwd())
        factory = filesystem_factory
    else:
        matches = list(itermatches(regexps))
        factory = simple_factory
    if not matches:
        sys.exit(NOTHING_SELECTED_EXIT_STATUS)

    with TTYLocker():
        res = curses.wrapper(Screen(factory, matches).mainloop)

    if not res:
        sys.exit(NOTHING_SELECTED_EXIT_STATUS)

    sys.stdout.write(separator(options).join(res))

if __name__ == '__main__':
    main()
