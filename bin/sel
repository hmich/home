#!/usr/bin/env python

# Copyright (c) 2008 Igor Akhmetov
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following
# conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.

from __future__ import with_statement

import os
import sys
import re
import operator
import string
import optparse

import curses
import curses.textpad
from curses.wrapper import wrapper

PATTERN_TIMEOUT = 2000

def cyclic_xrange(start, cnt):
    for idx in xrange(start, cnt):
        yield idx
    for idx in xrange(start):
        yield idx

class Item(object):
    def __init__(self, str):
        self._str = str
        self.marked = False

    def __str__(self):
        return self._str

    def toggle(self):
        self.marked = not self.marked

class Screen:
    def __init__(self, items):
        self.offset = 0
        self.idx = 0
        self.items = items
        self.has_marked = False

    def getch(self):
        self.scr.timeout(PATTERN_TIMEOUT)
        return self.scr.getch()

    def refresh(self):
        self.scr.refresh()

    def items_num(self):
        return len(self.items)

    def bound_idx(self, idx):
        return max(0, min(idx, self.items_num() - 1))

    def bound_offset(self, offset):
        return max(0, min(offset, self.items_num() - self.lines))

    def contains_line(self, line):
        return self.offset <= line < self.offset + self.lines

    def draw_item(self, idx):
        if not self.contains_line(idx):
            return

        item = self.items[idx]
        y = idx - self.offset
        fmt = (str(idx + 1).rjust(len(str(self.items_num())) + 1) + ' ' +
              ("[%(marked)s] " if self.has_marked else '') + "%(text)s")
        s = fmt % {'marked': 'x' if item.marked else ' ', 'text': str(item)}

        attr = curses.color_pair(0)
        if item.marked:
            attr |= curses.A_BOLD
        if self.idx == idx:
            attr |= curses.color_pair(1)

        self.scr.attrset(attr)
        self.clear_line(y)
        self.scr.addstr(y, 0, s + ' ' * (curses.COLS - len(s) - 1))
        self.refresh()

    def clear_line(self, line):
        self.scr.move(line, 0)
        self.scr.clrtoeol()

    def redraw(self):
        for curidx in xrange(self.offset, self.offset + self.lines):
            if curidx < self.items_num():
                self.draw_item(curidx)
            else:
                self.clear_line(curidx - self.offset)

    def update_has_marked(self):
        if self.has_marked != reduce(operator.or_, [item.marked for item in self.items]):
            self.has_marked = not self.has_marked
            self.redraw()

    def _change_item(self, arg):
        previdx, prevoffset = self.idx, self.offset

        self.idx = self.bound_idx(arg)
        if not self.contains_line(self.idx):
            if self.idx < self.offset:
                self.offset = self.idx
            else:
                self.offset = self.idx - self.lines + 1

        self.offset = self.bound_offset(self.offset)

        if self.offset == prevoffset:
            self.draw_item(previdx)
            self.draw_item(self.idx)
        else:
            self.redraw()

    next_item  = lambda self: self._change_item(self.idx + 1)
    prev_item  = lambda self: self._change_item(self.idx - 1)
    first_item = lambda self: self._change_item(0)
    last_item  = lambda self: self._change_item(self.items_num() - 1)

    def next_page(self):
        if self.idx - self.offset == self.lines - 1:
            self._change_item(self.idx + self.lines)
        else:
            self._change_item(self.offset + self.lines - 1)

    def prev_page(self):
        if self.idx == self.offset:
            self._change_item(self.idx - self.lines)
        else:
            self._change_item(self.offset)

    def current_item(self):
        return self.items[self.idx]

    def toggle_item(self):
        item = self.current_item()
        item.toggle()
        self.update_has_marked()
        self.draw_item(self.idx)

    def invert_selection(self):
        for item in self.items:
            item.toggle()
        self.update_has_marked()
        self.redraw()

    def select_all(self):
        for item in self.items:
            item.marked = True
        self.update_has_marked()
        self.redraw()

    def focus_pattern(self, pat):
        for idx in cyclic_xrange(self.idx, self.items_num()):
            if pat in str(self.items[idx]).lower():
                self._change_item(idx)
                break

    def print_status(self, str):
        scr = self.scr
        scr.attrset(curses.color_pair(0))
        self.clear_line(curses.LINES - 1)
        scr.addstr(str)
        self.refresh()

    def query(self, str):
        str += ' '
        self.print_status(str)

        win = curses.newwin(1, curses.COLS - len(str), curses.LINES - 1, len(str))
        q = curses.textpad.Textbox(win)
        res = q.edit()

        self.print_status('')

        return res

    def goto_line(self):
        line = self.query("Goto line:")
        self._change_item(int(line) - 1)

    def mark_by_regex(self):
        s = self.query("Mark by regex:")
        try:
            regex = re.compile(s.strip())
        except:
            return

        for item in self.items:
            if regex.search(str(item)):
                item.marked = True
        self.update_has_marked()
        self.redraw()

    def enumerate_marked(self):
        if self.has_marked:
            for (idx, item) in enumerate(self.items):
                if item.marked:
                    yield (idx, item)
        else:
            yield (self.idx, self.current_item())

    def enumerate_unmarked(self):
        if self.has_marked:
            for (idx, item) in enumerate(self.items):
                if not item.marked:
                    yield (idx, item)
        else:
            for (idx, item) in enumerate(self.items):
                if idx != self.idx:
                    yield (idx, item)

    def remove_marked(self):
        newidx = -1
        newitems = []
        for (idx, item) in self.enumerate_unmarked():
            if idx >= self.idx and newidx == -1:
                newidx = len(newitems)
            newitems.append(item)

        if newidx == -1:
            newidx = len(newitems) - 1

        self.items = newitems
        if not self.items:
            return
        self.idx = newidx
        self._change_item(newidx)
        self.update_has_marked()
        self.redraw()

    def mainloop(self, stdscr):
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
        curses.curs_set(0)

        self.scr = stdscr
        self.lines = curses.LINES - 1
        self.update_has_marked()
        self.redraw()

        pattern = ''

        bindings = {
            curses.KEY_DOWN:   self.next_item,
            ord('J'):          self.next_item,
            curses.KEY_UP:     self.prev_item,
            ord('K'):          self.prev_item,
            curses.KEY_NPAGE:  self.next_page,
            ord('H'):          self.next_page,
            curses.KEY_PPAGE:  self.prev_page,
            ord('L'):          self.prev_page,
            curses.KEY_HOME:   self.first_item,
            ord('<'):          self.first_item,
            curses.KEY_END:    self.last_item,
            ord('>'):          self.last_item,
            curses.KEY_DC:     self.remove_marked,
            ord('D'):          self.remove_marked,
            curses.KEY_IC:     self.toggle_item,
            ord(' '):          self.toggle_item,
            ord('!'):          self.invert_selection,
            ord('*'):          self.select_all,
            ord('G'):          self.goto_line,
            ord('%'):          self.mark_by_regex,
        }

        while 1:
            try:
                c = self.getch()
            except KeyboardInterrupt:
                return []

            if c == ord('\n'):
                return [item for (_, item) in self.enumerate_marked()]
            elif bindings.get(c):
                bindings[c]()
                pattern = ''
                if not self.items:
                    return []
            elif 0 <= c < 256 and (chr(c) in string.printable):
                pattern += chr(c)
                self.focus_pattern(pattern)
            else:
                pattern = ''

        return []

class TTYLocker:
    def __enter__(self):
        self._saved_stdin = os.dup(0)
        self._saved_stdout = os.dup(1)

        os.close(0)
        os.close(1)

        os.open('/dev/tty', os.O_RDONLY)
        os.open('/dev/tty', os.O_RDWR)

    def __exit__(self, exc_type, exc_val, exc_tb):
        os.close(0)
        os.close(1)

        os.dup(self._saved_stdin)
        os.dup(self._saved_stdout)

def process_args():
    parser = optparse.OptionParser()
    parser.add_option('-l', '--lines', action='store_true', dest='lines_regex', default=False)

    global options
    (options, args) = parser.parse_args()

    if options.lines_regex:
        args.append('^.*$')
    args = args or ['[\S]+']

    return [re.compile(str) for str in args]

def find_matches(regexps):
    res = []
    for line in sys.stdin.xreadlines():
        for re in regexps:
            res.extend(re.findall(line))
    return res

def print_items(items):
    for item in items:
        print str(item),

def main():
    items = [Item(s) for s in find_matches(process_args())]
    if not items:
        return

    with TTYLocker():
        items = wrapper(Screen(items).mainloop)

    print_items(items)

if __name__ == '__main__':
    main()
